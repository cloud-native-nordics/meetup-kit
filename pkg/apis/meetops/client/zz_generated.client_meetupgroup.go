/*
	Note: This file is autogenerated! Do not edit it manually!
	Edit client_meetupgroup_template.go instead, and run
	hack/generate-client.sh afterwards.
*/

package client

import (
	"fmt"

	api "github.com/cloud-native-nordics/meetup-kit/pkg/apis/meetops"

	log "github.com/sirupsen/logrus"
	"github.com/weaveworks/gitops-toolkit/pkg/runtime"
	"github.com/weaveworks/gitops-toolkit/pkg/storage"
	"github.com/weaveworks/gitops-toolkit/pkg/storage/filterer"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

// MeetupGroupClient is an interface for accessing MeetupGroup-specific API objects
type MeetupGroupClient interface {
	// New returns a new MeetupGroup
	New() *api.MeetupGroup
	// Get returns the MeetupGroup matching given UID from the storage
	Get(runtime.UID) (*api.MeetupGroup, error)
	// Set saves the given MeetupGroup into persistent storage
	Set(*api.MeetupGroup) error
	// Patch performs a strategic merge patch on the object with
	// the given UID, using the byte-encoded patch given
	Patch(runtime.UID, []byte) error
	// Find returns the MeetupGroup matching the given filter, filters can
	// match e.g. the Object's Name, UID or a specific property
	Find(filter filterer.BaseFilter) (*api.MeetupGroup, error)
	// FindAll returns multiple MeetupGroups matching the given filter, filters can
	// match e.g. the Object's Name, UID or a specific property
	FindAll(filter filterer.BaseFilter) ([]*api.MeetupGroup, error)
	// Delete deletes the MeetupGroup with the given UID from the storage
	Delete(uid runtime.UID) error
	// List returns a list of all MeetupGroups available
	List() ([]*api.MeetupGroup, error)
}

// MeetupGroups returns the MeetupGroupClient for the IgniteInternalClient instance
func (c *MeetOpsInternalClient) MeetupGroups() MeetupGroupClient {
	if c.meetupgroupClient == nil {
		c.meetupgroupClient = newMeetupGroupClient(c.storage, c.gv)
	}

	return c.meetupgroupClient
}

// meetupgroupClient is a struct implementing the MeetupGroupClient interface
// It uses a shared storage instance passed from the Client together with its own Filterer
type meetupgroupClient struct {
	storage  storage.Storage
	filterer *filterer.Filterer
	gvk      schema.GroupVersionKind
}

// newMeetupGroupClient builds the meetupgroupClient struct using the storage implementation and a new Filterer
func newMeetupGroupClient(s storage.Storage, gv schema.GroupVersion) MeetupGroupClient {
	return &meetupgroupClient{
		storage:  s,
		filterer: filterer.NewFilterer(s),
		gvk:      gv.WithKind(api.KindMeetupGroup.Title()),
	}
}

// New returns a new Object of its kind
func (c *meetupgroupClient) New() *api.MeetupGroup {
	log.Tracef("Client.New; GVK: %v", c.gvk)
	obj, err := c.storage.New(c.gvk)
	if err != nil {
		panic(fmt.Sprintf("Client.New must not return an error: %v", err))
	}
	return obj.(*api.MeetupGroup)
}

// Find returns a single MeetupGroup based on the given Filter
func (c *meetupgroupClient) Find(filter filterer.BaseFilter) (*api.MeetupGroup, error) {
	log.Tracef("Client.Find; GVK: %v", c.gvk)
	object, err := c.filterer.Find(c.gvk, filter)
	if err != nil {
		return nil, err
	}

	return object.(*api.MeetupGroup), nil
}

// FindAll returns multiple MeetupGroups based on the given Filter
func (c *meetupgroupClient) FindAll(filter filterer.BaseFilter) ([]*api.MeetupGroup, error) {
	log.Tracef("Client.FindAll; GVK: %v", c.gvk)
	matches, err := c.filterer.FindAll(c.gvk, filter)
	if err != nil {
		return nil, err
	}

	results := make([]*api.MeetupGroup, 0, len(matches))
	for _, item := range matches {
		results = append(results, item.(*api.MeetupGroup))
	}

	return results, nil
}

// Get returns the MeetupGroup matching given UID from the storage
func (c *meetupgroupClient) Get(uid runtime.UID) (*api.MeetupGroup, error) {
	log.Tracef("Client.Get; UID: %q, GVK: %v", uid, c.gvk)
	object, err := c.storage.Get(c.gvk, uid)
	if err != nil {
		return nil, err
	}

	return object.(*api.MeetupGroup), nil
}

// Set saves the given MeetupGroup into the persistent storage
func (c *meetupgroupClient) Set(meetupgroup *api.MeetupGroup) error {
	log.Tracef("Client.Set; UID: %q, GVK: %v", meetupgroup.GetUID(), c.gvk)
	return c.storage.Set(c.gvk, meetupgroup)
}

// Patch performs a strategic merge patch on the object with
// the given UID, using the byte-encoded patch given
func (c *meetupgroupClient) Patch(uid runtime.UID, patch []byte) error {
	return c.storage.Patch(c.gvk, uid, patch)
}

// Delete deletes the MeetupGroup from the storage
func (c *meetupgroupClient) Delete(uid runtime.UID) error {
	log.Tracef("Client.Delete; UID: %q, GVK: %v", uid, c.gvk)
	return c.storage.Delete(c.gvk, uid)
}

// List returns a list of all MeetupGroups available
func (c *meetupgroupClient) List() ([]*api.MeetupGroup, error) {
	log.Tracef("Client.List; GVK: %v", c.gvk)
	list, err := c.storage.List(c.gvk)
	if err != nil {
		return nil, err
	}

	results := make([]*api.MeetupGroup, 0, len(list))
	for _, item := range list {
		results = append(results, item.(*api.MeetupGroup))
	}

	return results, nil
}
